package com.cairn.gape;

import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import com.cairn.common.utils.Timer;
import com.cairn.gape.chromosome.SuperpositionChromosome;
import com.cairn.gape.feature.Feature.FeatureType;
import com.cairn.gape.feature.FeatureMapping;
import com.cairn.gape.molecule.GaMolecule;
import com.cairn.molecule.Molecule;

/**
 * Pharm search is an variant of the GAPE algorithm. A query set of molecules is
 * held fixed and other molecules are aligned to them using the gape scoring
 * function.
 *
 * @author Gareth Jones
 */
public class PharmSearch extends Superposition {
    /*
     * Runs Pharm search. Takes two molecule files as input- the first contains
     * a set of aligned queries (possibly generated by GAPE). The second
     * contains a set of database molecules. The algorithm uses GAPE to fit the
     * target compounds molecule by molecule to the queries and ranks them.
     *
     * Pharm search may run into memory problems if run with JVM default memory.
     *
     * (non-Javadoc)
     *
     * @see com.cairn.gape.Superposition#main(java.lang.String[])
     */
    public static void main(String args[]) {
        PharmSearch ps = new PharmSearch();

        if (args.length < 2) {
            System.out.println("\nUsage: PharmSearch <conf file> <molecule files..>");
            System.out.println();
            System.out.println("First molecule file is aligned queries, "
                    + "remainder are database files");
            System.exit(0);
        }

        System.out.print("\n\nGAPE(PharmSearch)\n");
        System.out.print("Gareth Jones\n\n");

        // do the init here rather than in searchMolecules- needs to be read
        // before loading in any compounds
        ps.init(args[0]);

        long mem = Runtime.getRuntime().maxMemory();
        if (mem == Long.MAX_VALUE)
            ps.infoMessageLogger.infoMessageln("Maximum memory Available");
        else {
            double meg = mem / (1024 * 1024);
            ps.infoMessageLogger.infoMessageln(meg + " MB memory avaliable");
        }

        List<GaMolecule> queryMols = GaMolecule.loadFiles(new String[]{args[1]},
                Molecule.FileType.UNKNOWN, Molecule.Source.FILE, ps.infoMessageLogger,
                true);
        // Strip out pharmacophore representations from input
        queryMols = queryMols.stream().filter(q -> !q.getName().contains("Pharmacophore"))
                .collect(Collectors.toList());

        String molFiles[] = Arrays.copyOfRange(args, 2, args.length);
        List<GaMolecule> database = GaMolecule.loadFiles(molFiles,
                Molecule.FileType.UNKNOWN, Molecule.Source.FILE, ps.infoMessageLogger,
                true);

        ps.fileFormat = Molecule.getType(molFiles[0]);

        // do the work
        ps.searchMolecules(queryMols, database);

    }
    private final List<SuperpositionChromosome> matches = new ArrayList<>();
    private volatile List<GaMolecule> queries, database;
    private volatile GaMolecule target;
    private volatile int databaseNo;
    private volatile FileWriter allSolutionsWriter;
    private int queryBinaryStringLength = 0;

    /**
     * Matches a database compound against the query molecule(s)
     *
     * @see Superposition#run()
     */
    private void matchTarget() {
        SuperpositionChromosome.setAllocated(false);

        solutions.clear();
        String targetName = target.getName();
        for (int i = 0; i < nRuns; i++) {

            // superclass method does gape alignment
            run(i);

            best = saveBest();
            solutions.add(best);

            int no = i + 1;
            infoMessageLogger.infoMessageln("\n\nTarget "+targetName+" Solution " + no + " "
                    + best.fitnessInfo()+"\n");

            infoMessageLogger.infoMessageln();

            pop.freePop();

            pop = null;
            // System.gc();
        }

        // Rank runs
        Map<SuperpositionChromosome, Integer> initialPositions = new HashMap<>();
        for (int i = 0; i < solutions.size(); i++) {
            initialPositions.put(solutions.get(i), i);
        }
        Collections.sort(solutions, chromosomeComparator());

        try {
            for (int i = 0; i < solutions.size(); i++) {
                int r = i + 1;
                SuperpositionChromosome c = solutions.get(i);
                int no = initialPositions.get(c) + 1;
                c.rebuild();
                if (scalePharmacophore)
                    c.addPharmInfo();

                infoMessageLogger.infoMessage("Target " +targetName + " Rank " + r + " solution " + no + " "
                        + c.fitnessInfo());

                String name = target.getName();
                int targetNo = databaseNo + 1;
                target.setName("Target " + targetNo + " GA rank " + r + " Name " + name);
                String info = "Pharmsearch solution rank " + r + " for database target "
                        + targetNo +" name "+name;
                target.write(fileFormat, allSolutionsWriter, info, incLonePairs);
                target.setName(name);

                if (i == 0)
                    matches.add(c);
            }

            allSolutionsWriter.flush();
            // Put best match in molecule coordinates.

            matches.get(databaseNo).rebuild();
            if (scalePharmacophore)
                matches.get(databaseNo).addPharmInfo();
        } catch (IOException ex) {
            throw new RuntimeException("matchTarget IO exception: " + ex);
        }

    }

    /**
     * Does the work of matching the query set of compounds to database
     * molecules.
     *
     * @param q
     * @param d
     */
    private void searchMolecules(List<GaMolecule> q, List<GaMolecule> d) {

        totalTimer = new Timer();
        runTimer = new Timer();

        queries = q;
        database = d;

        try {
            // best hits
            matches.clear();
            // stores current hits
            solutions.clear();
            // file for all solutions
            String allSolutionsFile = "All_Solutions"
                    + (fileFormat == Molecule.FileType.SDF ? ".sdf" : ".mol2");
            allSolutionsWriter = new FileWriter(allSolutionsFile);

            setupQuery();

            // loop through all the database compounds
            for (int i = 0; i < database.size(); i++) {
                runTimer.reset();

                databaseNo = i;
                target = database.get(i);
                setupTarget();
                matchTarget();
                target.free();

                int no = i + 1;
                runTimer.interval();
                infoMessageLogger.infoMessageln("Database " + no + " " + target.getName()
                        + " Execution Time " + runTimer.info() + "\n\n");
                runTimer.reset();
            }

            allSolutionsWriter.close();
            summarize();

            totalTimer.interval();
            infoMessageLogger.infoMessageln("Total  Execution Time " + totalTimer.info());

        } catch (IOException ex) {
            System.err.println("PharmSearch: IOException: " + ex);
        }
    }

    /**
     * Sets up the query molecule(s). Sets all the query compounds to be both
     * rigid and fixed so they don't move during GAPE fitting.
     */
    private void setupQuery() {
        commonMolSetup();

        molecules = new ArrayList<>();
        binaryEntryPoints = new int[queries.size() + 1];

        int minFeaturesNo = 0;
        int no = 0;
        int nBits = 0;
        for (GaMolecule query : queries) {
            query.setRigid(true);
            query.setFixed(true);

            query.setProblem(this);
            query.setup();
            if (query.getNMappingFeatures() < queries.get(minFeaturesNo)
                    .getNMappingFeatures()) {
                minFeaturesNo = no;
            }
            molecules.add(query);
            binaryEntryPoints[no] = nBits;
            nBits += query.getConformationalBitLength();
            no++;
        }

        queryBinaryStringLength = nBits;

        // create space for target
        molecules.add(null);

        baseMolecule = queries.get(minFeaturesNo);
        baseMoleculeNo = minFeaturesNo;
        fittingMolecule = queries.get(minFeaturesNo);
        fittingMoleculeNo = minFeaturesNo;

        integerEntryPoints = new int[]{0};
        integerStringLength = baseMolecule.getNMappingFeatures();
        integerStringRanges = new int[integerStringLength];
    }

    /**
     * Sets up the target for GAPE. Finds the number of conformational bits and
     * the integer ranges for feature fitting.
     *
     * @see GaMolecule#setup()
     */
    private void setupTarget() {
        target.setProblem(this);
        target.setup();
        if (tordist != null)
            tordist.moleculeMatchTordist(target);

        int nBits = target.getConformationalBitLength();
        molecules.set(molecules.size() - 1, target);
        binaryStringLength = queryBinaryStringLength + nBits;
        binaryEntryPoints[binaryEntryPoints.length-1] = queryBinaryStringLength;

        Map<FeatureType, FeatureMapping> baseFeatures = baseMolecule.getFeatureMappings();
        int pos = 0;
        for (FeatureMapping baseFeatureMapping : baseFeatures.values()) {
            if (!baseFeatureMapping.isMapping()) {
                continue;
            }
            FeatureMapping otherFeatures = target.getFeatureMappings(baseFeatureMapping
                    .getFeatureType());
            for (int k = 0; k < baseFeatureMapping.getNFeatures(); k++) {
                integerStringRanges[pos] = otherFeatures.getNFeatures();
                pos++;
            }
        }

        setWeights();

        setupFeatureClustering();
    }

    /**
     * Ranks all the database solutions and writes out a ordered structure
     * summary file.
     */
    private void summarize() {// Rank runs
        Map<SuperpositionChromosome, Integer> initialPositions = new HashMap<>();
        for (int i = 0; i < matches.size(); i++) {
            initialPositions.put(matches.get(i), i);
        }
        Collections.sort(matches, chromosomeComparator());

        try {
            String summaryFile = "Matches"
                    + (fileFormat == Molecule.FileType.SDF ? ".sdf" : ".mol2");
            FileWriter summaryWriter = new FileWriter(summaryFile);

            for (GaMolecule query : queries) {
                String name = query.getName();
                query.setName("Query " + name);
                query.setPharmDescriptions(null);
                query.write(fileFormat, summaryWriter, "GA Pharmsearch Query Molecule",
                        incLonePairs);
                query.setName(name);
                summaryWriter.flush();
            }

            for (int i = 0; i < matches.size(); i++) {

                SuperpositionChromosome c = matches.get(i);
                target = database.get(initialPositions.get(c));

                int r = i + 1;
                int no = initialPositions.get(c) + 1;

                infoMessageLogger.infoMessage("Rank " + r + " Target " + no + " name "
                        + target.getName() + " " + c.fitnessInfo());

                String name = target.getName();
                target.setName(" Target " + no + " Rank " + r + " Name " + name);
                target.write(fileFormat, summaryWriter, "Pharmsearch Database Target "
                        + no + " Name "+ name + " Rank " + r, incLonePairs);
                target.setName(name);
                summaryWriter.flush();
            }

            summaryWriter.close();
        } catch (IOException ex) {
            throw new RuntimeException("IOException " + ex);
        }
    }
}
